<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chat</title>
    <style>
      @import url("https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css");
      @import url("https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css");

      img.position-absolute {
        max-height: 2rem;
      }

      .toast-body img {
        max-height: 28px;
      }

      .toast-header img {
        max-height: 18px;
      }

      .animate__spin {
        opacity: 0;
        animation: spin 4s ease-out;
      }

      @keyframes spin {
        0% {
          opacity: 0;
          transform: translateY(0) translateX(0) rotateY(0deg);
        }

        33% {
          opacity: 1;
        }

        66% {
          opacity: 1;
        }

        100% {
          opacity: 0;
          transform: translateY(3000%) translateX(1000%) rotateY(360deg);
        }
      }
    </style>
  </head>

  <body class="overflow-hidden w-100 vh-100">
    <div
      class="toast-container position-absolute bottom-0 end-0 p-3 overflow-hidden"
      id="toasts"
    ></div>
    <script type="module">
      import Toast from "https://esm.run/bootstrap/js/dist/toast";
      import format from "https://esm.run/date-fns/format";
      import tinyColor from "https://esm.run/tinycolor2";

      function RNG(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min)) + min;
      }

      function animateCSS(element, animation, prefix = "animate__") {
        return new Promise((resolve, reject) => {
          const animationName = `${prefix}${animation}`;
          const node =
            typeof element === "object" &&
            (element instanceof Node || element instanceof HTMLElement)
              ? element
              : document.querySelector(element);
          node.classList.add(`${prefix}animated`, animationName);
          function handleAnimationEnd(event) {
            event.stopPropagation();
            node.classList.remove(`${prefix}animated`, animationName);
            resolve("Animation ended");
          }
          node.addEventListener("animationend", handleAnimationEnd, {
            once: true,
          });
        });
      }

      function lumeColor(color, invert = false) {
        color = tinyColor(color);
        if (color.isLight()) {
          if (invert) return "dark";
          return "light";
        }
        if (color.isDark()) {
          if (invert) return "light";
          return "dark";
        }
      }

      function attachEmotes(message, emotes) {
        let text = html_encode(message);
        return text.replace(/([^\s]*)/gi, function (m, key) {
          let result = emotes.filter((emote) => {
            return html_encode(emote.name) === key;
          });
          if (typeof result[0] !== "undefined") {
            let url = result[0]["imageUrl"];
            return `<img class="emote" src="${url}"/>`;
          } else return key;
        });
      }

      function html_encode(e) {
        if (typeof e === "string") {
          return e.replace(/[<>"^]/g, function (e) {
            return `&#${e.charCodeAt(0)};`;
          });
        }
      }

      (function connectWs() {
        if ("WebSocket" in window) {
          const ws = new WebSocket("ws://localhost:8080/");

          ws.onopen = function () {
            ws.send(
              JSON.stringify({
                request: "Subscribe",
                events: {
                  Twitch: ["ChatMessage", "FirstWord"],
                  fileWatcher: ["Changed"],
                },
                id: "chat",
              })
            );
          };

          ws.onmessage = async (evtData) => {
            const { data, type } = evtData;
            if (type !== "message") return;
            const { data: event, status } = JSON.parse(data);
            if (event) console.log(event);
            const roles = ["viewer", "vip", "mod", "streamer"];

            if (event?.name === "eventImage" && event?.lines?.length) {
              const image = document.createElement("img");
              image.src = event.lines.pop();
              image.style.maxHeight = "250px";
              const content = document.createElement("div");
              content.append(image);
              content.classList.add(
                "position-absolute",
                "h-100",
                "w-100",
                "d-flex",
                "justify-content-center",
                "align-items-center"
              );
              document.body.append(content);
              animateCSS(image, "fadeIn").then(() =>
                animateCSS(image, "rubberBand").then(() =>
                  animateCSS(image, "fadeOut").then(() => content.remove())
                )
              );
            }

            if (event?.message) {
              let { color } = event.message;
              const {
                msgId,
                username,
                displayName,
                subscriber,
                role,
                emotes,
                message,
                isMe,
                isHighlighted,
                isCustomReward,
                hasBits,
                isReply,
              } = event.message;
              const roleName = roles[role - 1];

              if (isCustomReward || isReply || hasBits) return;
              if (typeof color === "undefined") color = tinyColor.random();

              if (subscriber && emotes && emotes.length) {
                emotes.map((emote, idx) => {
                  const elEmote = document.createElement("img");
                  elEmote.src = emote.imageUrl.replace("default", "static");
                  elEmote.classList.add("position-absolute");
                  elEmote.style.right = `${RNG(10, window.innerWidth - 10)}px`;
                  elEmote.style.top = "0px";
                  animateCSS(elEmote, "spin").then(() => elEmote.remove());
                  document.body.append(elEmote);
                });
              }

              const profilePic = await fetch(
                `https://decapi.me/twitch/avatar/${username}`
              ).then((res) => res.text());
              const toast = document.createElement("div");
              toast.id = msgId;
              toast.classList.add("toast");
              if (isHighlighted) toast.classList.add("bg-dark", "text-light");
              toast.ariaAtomic = true;
              toast.ariaLive = "assertive";
              toast.setAttribute("role", "chat");
              toast.innerHTML = `
      <div class="toast-header text-${lumeColor(
        color,
        true
      )}" style="background-color: ${color};">
        <img src="${profilePic}" class="img-fluid rounded-circle me-2">
        <span class="me-auto fw-bold fs-6">${displayName}</span>
        <small>${format(new Date(), "HH:mm")}</small>
      </div>
      <div class="toast-body ${
        isMe ? "fst-italic" : "fst-normal"
      }">${attachEmotes(message, emotes)}</div>
      `;
              document.getElementById("toasts").append(toast);

              animateCSS(toast, "fadeInRight").then(() => {
                setTimeout(() => {
                  animateCSS(toast, "fadeOutRight").then(() => toast.remove());
                }, 4000);
              });

              new Toast(toast, {
                animation: false,
                autohide: false,
              }).show();
            }
          };

          ws.onclose = function () {
            setTimeout(connectWs, 10000);
          };
        }
      })();
    </script>
  </body>
</html>
