<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Eventos</title>
    <style>
      @import url("https://fonts.googleapis.com/css?family=Montserrat");
      @import url("https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css");
      @import url("https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css");

      body {
        font-family: "Montserrat", sans-serif;
        font-weight: 400;
      }

      .emote {
        max-width: 2rem;
      }

      .alert-container {
        opacity: 0;
        color: rgb(255, 255, 255);
        font-size: 14px;
        transform: translate(0) scale(0.75) skewY(176deg);
        transform-style: flat;
      }

      .alert-title {
        white-space: nowrap;
        text-overflow: ellipsis;
        background: #d835aa;
        padding: 8px 10px;
        border-radius: 20px;
        top: -10px;
      }

      .alert-message {
        opacity: 0;
        color: #373d3f;
        background: #fff;
        padding: 8px 10px;
        border-radius: 1rem;
        box-shadow: rgba(99, 99, 99, 0.2) 0px 2px 8px 0px;
        top: 100px;
      }

      .alert-message::before {
        position: absolute;
        content: "";
        top: -10px;
        width: 0;
        height: 0;
        left: 50%;
        bottom: 100%;
        border: 0.75rem solid transparent;
        border-top: none;
        border-bottom-color: #fff;
        filter: drop-shadow(0 -0.0625rem 0.0625rem rgba(0, 0, 0, 0.1));
      }

      .alert-box {
        height: 90px !important;
        border-radius: 15px;
        background: rgb(36, 6, 73);
        padding: 20px;
        border: 3px solid #2fc9c5;
      }

      .alert-name {
        font-size: 64px;
        text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.5);
      }

      span.animate__animated {
        display: inline-block;
      }

      .alert-box.animate__animated:after {
        position: absolute;
        content: "";
        opacity: 0;
        height: 100%;
        width: 200%;
        left: -200%;
        top: 0;
        background: rgba(255, 255, 255, 0.13);
        background: linear-gradient(
          to right,
          rgba(255, 255, 255, 0.13) 0%,
          rgba(255, 255, 255, 0.13) 77%,
          rgba(255, 255, 255, 0.5) 92%,
          rgba(255, 255, 255, 0) 100%
        );
        animation: shine 4s ease;
        transform: rotate(30deg);
      }

      @keyframes shine {
        50% {
          opacity: 1;
        }

        75% {
          opacity: 1;
          left: 200%;
        }

        100% {
          opacity: 0;
        }
      }
    </style>
  </head>

  <body
    class="overflow-hidden d-flex justify-content-center align-items-center vh-100"
  >
    <div
      class="alert-container position-relative d-flex justify-content-center align-items-center"
    >
      <div class="alert-box position-relative overflow-hidden w-100">
        <div
          class="alert-name d-flex justify-content-center align-items-center fw-bold w-100 h-100"
        >
          <span id="username-container"></span>
        </div>
      </div>
      <div class="alert-title position-absolute"></div>
      <div class="alert-message position-absolute text-center"></div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/fitty@2.3.0/dist/fitty.min.js"></script>
    <script>
      const queue = [];
      let playing = false;

      function attachEmotes(message, emotes) {
        message = html_encode(message);
        emotes = emotes.map((emote) => {
          return {
            text: html_encode(
              message.substring(emote.StartIndex, emote.EndIndex + 1)
            ),
            image: emote.ImageUrl,
          };
        });
        return message.replace(/([^\s]*)/gi, function (text) {
          if (!text.length) return text;
          let result = emotes.find((emote) => emote.text === html_encode(text));
          if (result) return `<img class="emote" src="${result.image}"/>`;
          return text;
        });
      }

      function html_encode(e) {
        if (typeof e === "string") {
          return e.replace(/[<>"^]/g, function (e) {
            return `&#${e.charCodeAt(0)};`;
          });
        }
      }

      (function connectWs() {
        if ("WebSocket" in window) {
          const ws = new WebSocket("ws://localhost:8080/");

          ws.onopen = function () {
            ws.send(
              JSON.stringify({
                request: "Subscribe",
                events: {
                  general: ["Custom"],
                },
                id: "events",
              })
            );
          };

          ws.onmessage = function (event) {
            try {
              event = JSON.parse(event?.data)?.data;
              if (!event) return;
              const eventData = event.hasOwnProperty("data")
                ? JSON.parse(event?.data)
                : null;
              if (!eventData) return;
              console.log(eventData);
              if (!eventData?.eventName) return;
              queue.push({
                type: eventData?.eventName,
                name: eventData?.user,
                message: eventData?.message,
                emotes: eventData?.cheerEmoteCount
                  ? eventData?.cheerEmotes
                  : eventData?.emoteCount
                  ? eventData?.emotes
                  : [],
              });
              alertEvent();
            } catch (err) {
              console.log(err);
            }
          };

          ws.onclose = function () {
            setTimeout(connectWs, 10000);
          };
        }
      })();

      async function alertEvent() {
        if (queue.length <= 0 || playing) return;
        playing = true;
        const event = queue.shift();

        const name = event.name ?? "anÃ´nimo",
          emotes = event.emotes || [],
          message = event.message,
          animation = "wobble",
          animate = (text, animation = "tada") =>
            text
              ?.split("")
              .map((char, index) => {
                return `<span class="animate__animated animate__${animation} animate__infinite" style="animation-delay: ${index}00ms;">${char}</span>`;
              })
              .join("");

        const alertContainer = document.querySelector(".alert-container"),
          alertMessage = document.querySelector(".alert-message"),
          alertTitle = document.querySelector(".alert-title"),
          userNameContainer = document.querySelector("#username-container");

        alertTitle.innerHTML = event.type;

        userNameContainer.innerHTML = animate(name, "tada");

        fitty("#username-container", {
          minSize: 14,
          maxSize: 64,
        });

        alertContainer.style.opacity = 1;

        animateCSS(".alert-container", "fadeIn");
        animateCSS(".alert-box", animation);
        animateCSS(".alert-title", animation);
        await animateCSS(".alert-name", animation);

        if (typeof message === "string" && message.length > 0) {
          alertMessage.innerHTML = attachEmotes(message, emotes);
          alertMessage.style.opacity = 1;
          await animateCSS(".alert-message", "fadeIn");
          hideEvent();
        } else {
          hideEvent();
        }

        function hideEvent() {
          setTimeout(function () {
            animateCSS(".alert-container", "fadeOut").then(() => {
              alertContainer.style.opacity = 0;
              alertMessage.style.opacity = 0;
              playing = false;
              alertEvent();
            });
          }, event.timeout ?? 4000);
        }
      }

      function animateCSS(element, animation, prefix = "animate__") {
        return new Promise((resolve, reject) => {
          const animationName = `${prefix}${animation}`;
          const node = document.querySelector(element);
          node.classList.add(`${prefix}animated`, animationName);
          function handleAnimationEnd(event) {
            event.stopPropagation();
            node.classList.remove(`${prefix}animated`, animationName);
            resolve("Animation ended");
          }
          node.addEventListener("animationend", handleAnimationEnd, {
            once: true,
          });
        });
      }
    </script>
  </body>
</html>
